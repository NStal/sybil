// Generated by CoffeeScript 1.6.3
(function() {
  var Collections, EventEmitter, ObjectID, async, collectionNames, config, dbConnector, dbServer, exports, mongodb, toBase64, toMD5;

  mongodb = require("mongodb");

  EventEmitter = (require("events")).EventEmitter;

  async = require("async");

  ObjectID = (require("mongodb")).ObjectID;

  config = {
    name: "sybil2",
    host: "localhost",
    port: 27017
  };

  dbServer = mongodb.Server(config.host, config.port, config.option);

  collectionNames = ["archive", "source"];

  dbConnector = new mongodb.Db(config.name, dbServer, {
    safe: false
  });

  module.exports = new EventEmitter();

  exports = module.exports;

  module.exports.ready = false;

  Collections = {};

  module.exports.Collections = Collections;

  toBase64 = function(string) {
    return new Buffer(string).toString("base64");
  };

  toMD5 = function(string) {
    return (require("crypto")).createHash("md5").update(new Buffer(string)).digest("hex");
  };

  dbConnector.open(function(err, db) {
    if (err || !db) {
      console.error("fail to connect to mongodb");
      console.error(err);
      process.exit(1);
    }
    dbConnector.db = db;
    return async.map(collectionNames, (function(collectionName, callback) {
      dbConnector.db.collection(collectionName, function(err, col) {
        if (err) {
          return callback(err);
        } else {
          return callback(null, col);
        }
      });
      return true;
    }), function(err, results) {
      var index, name, _i, _len;
      if (err) {
        console.error("fail to prefetch Collections");
        process.exit(1);
        return;
      }
      for (index = _i = 0, _len = collectionNames.length; _i < _len; index = ++_i) {
        name = collectionNames[index];
        Collections[name] = results[index];
      }
      module.exports.ready = true;
      return module.exports.emit("ready");
    });
  });

  exports.saveArchive = function(archive, callback) {
    archive._id = toMD5(archive.guid);
    return Collections.archive.insert(archive, {
      safe: true
    }, function(err, item) {
      if (err) {
        if (err.code === 11000) {
          callback("duplicate");
        } else {
          callback(err);
        }
        return;
      }
      return callback(null, item);
    });
  };

  exports.saveSource = function(source, callback) {
    source._id = toMD5(source.guid);
    return Collections.source.insert(source, {
      safe: true
    }, function(err, item) {
      if (err) {
        if (err.code === 11000) {
          callback("duplicate");
        } else {
          callback(err);
        }
        return;
      }
      return callback(null, item);
    });
  };

  exports.getSource = function(guid, callback) {
    return Collections.source.findOne({
      guid: guid
    }, function(err, item) {
      if (err) {
        callback("db error");
        return;
      }
      if (!item) {
        callback("not found");
        return;
      }
      return callback(null, item);
    });
  };

  exports.getSources = function(callback) {
    var cursor;
    cursor = Collections.source.find({});
    return cursor.toArray(function(err, arr) {
      if (err) {
        callback(err);
        return;
      }
      return callback(null, arr);
    });
  };

  exports.getSourceArchives = function(guid, callback) {
    var cursor;
    cursor = Collections.archive.find({
      sourceGuid: guid
    });
    return cursor.toArray(function(err, arr) {
      if (err) {
        callback(err);
        return;
      }
      return callback(null, arr);
    });
  };

  exports.updateUnreadCount = function(callback) {
    var cursor;
    cursor = Collections.source.find();
    return cursor.toArray(function(err, arr) {
      if (err) {
        callback(err);
        return;
      }
      return (require("async")).eachSeries(arr, (function(source, done) {
        return Collections.archive.find({
          sourceGuid: source.guid,
          hasRead: {
            $exists: false
          }
        }).count(function(err, count) {
          return Collections.source.update({
            _id: source._id
          }, {
            $set: {
              unreadCount: count
            }
          }, {
            safe: true
          }, function(err) {
            return done();
          });
        });
      }), function(err) {
        return callback(err);
      });
    });
  };

  exports.markArchiveAsRead = function(guid, callback) {
    return Collections.update({
      guid: guid
    }, {
      $set: {
        read: true
      }
    }, {
      safe: true
    }, function(err, update) {
      return callback(err, updates);
    });
  };

  exports.close = function() {
    return dbConnector.close();
  };

}).call(this);
