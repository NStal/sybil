// Generated by CoffeeScript 1.8.0
(function() {
  var EndlessListRenderer, Pack, ScrollChecker,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __slice = [].slice;

  ScrollChecker = require("/util/scrollChecker");

  EndlessListRenderer = (function(_super) {
    __extends(EndlessListRenderer, _super);

    function EndlessListRenderer(scrollable, createMethod) {
      this.scrollable = scrollable;
      this.createMethod = createMethod;
      EndlessListRenderer.__super__.constructor.call(this);
      this.renderCompromiseFix = 600;
      this.bottomPadding = 300;
      this.packs = [];
      this.datas = [];
      this.wrapper = document.createElement("div");
      this.buffer = document.createElement("div");
      this.buffer$ = $(this.buffer);
      this.wrapper$ = $(this.wrapper);
      this.wrapper.appendChild(this.buffer);
      this.bufferList = Leaf.Widget.makeList(this.buffer);
      this.bufferList.on("child/add", function(widget) {
        widget.isRealized = true;
        return widget.pack.isRealized = true;
      });
      this.bufferList.on("child/remove", function(widget) {
        return widget.pack.isRealized = false;
      });
      this.reset();
      this.scrollChecker = new ScrollChecker(this.scrollable);
      this.scrollChecker.eventDriven = true;
      this.scrollChecker.on("scroll", (function(_this) {
        return function() {
          return _this.adjustBufferList();
        };
      })(this));
      this.scrollable.appendChild(this.wrapper);
    }

    EndlessListRenderer.prototype.indexOf = function(item) {
      if (item instanceof Leaf.Widget) {
        return item.pack.index;
      } else if (item instanceof Pack) {
        return item.index;
      }
      return item.__index || null;
    };

    EndlessListRenderer.prototype.reset = function() {
      this.start = -1;
      this.end = -1;
      this.wrapper.style.minHeight = "0";
      this.bufferList.length = 0;
      this.top = 0;
      this.packs.length = 0;
      this.wrapper$.css({
        width: "100%",
        minHeight: 0
      });
      return this.buffer$.css({
        width: "100%",
        top: 0,
        position: "absolute",
        left: 0
      });
    };

    EndlessListRenderer.prototype.add = function() {
      var data, datas, index, packs, _i, _len, _ref;
      datas = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      packs = datas.map((function(_this) {
        return function(data) {
          return new Pack(data, _this.createMethod);
        };
      })(this));
      this.addPack.apply(this, packs);
      for (index = _i = 0, _len = datas.length; _i < _len; index = ++_i) {
        data = datas[index];
        data.__index = index + this.datas.length;
      }
      return (_ref = this.datas).push.apply(_ref, datas);
    };

    EndlessListRenderer.prototype.getPackByHeight = function(height) {
      var index, item, _i, _ref;
      for (index = _i = _ref = this.packs.length - 1; _ref <= 0 ? _i <= 0 : _i >= 0; index = _ref <= 0 ? ++_i : --_i) {
        item = this.packs[index];
        if (item.bottom > height && item.top < height) {
          return item;
        }
      }
      return item;
    };

    EndlessListRenderer.prototype.addPack = function() {
      var index, pack, packs, _i, _len, _ref;
      packs = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      console.debug("add packs", packs);
      for (index = _i = 0, _len = packs.length; _i < _len; index = ++_i) {
        pack = packs[index];
        pack.index = index + this.packs.length;
      }
      (_ref = this.packs).push.apply(_ref, packs);
      return this.adjustBufferList();
    };

    EndlessListRenderer.prototype.adjustBufferList = function() {
      var afters, befores, between, bufferViewPort, end, index, intersect, item, pack, shareEnd, shareStart, start, toAddEnd, toAddStart, toRemove, viewPort, _i, _j, _k, _l, _len, _len1, _len2, _m, _n, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8;
      if (this._hint && this.buffer.contains(this._hint)) {
        this.buffer.removeChild(this._hint);
      }
      viewPort = this.getViewPort(this.renderCompromiseFix);
      for (index = _i = _ref = this.start, _ref1 = this.end; _ref <= _ref1 ? _i <= _ref1 : _i >= _ref1; index = _ref <= _ref1 ? ++_i : --_i) {
        if (index < 0) {
          continue;
        }
        item = this.packs[index];
        item.calculateSize();
      }
      this.reflowAfter(this.start);
      start = null;
      end = null;
      _ref2 = this.packs;
      for (index = _j = 0, _len = _ref2.length; _j < _len; index = ++_j) {
        item = _ref2[index];
        if (!item.size) {
          console.debug("nobody has size", index, this.packs.length);
          break;
        }
        if (item.bottom > viewPort.top && item.top < viewPort.bottom) {
          if (start === null) {
            start = index;
          }
          end = index;
        }
      }
      intersect = function(a0, a1, b0, b1) {
        var left, right;
        left = Math.max(a0, b0);
        right = Math.min(a1, b1);
        if (right - left < 0) {
          return [-1, -1];
        }
        return [left, right];
      };
      between = function(start, end, number) {
        return number <= end && number >= start;
      };
      if (start == null) {
        start = -1;
      }
      if (end == null) {
        end = -1;
      }
      _ref3 = intersect(start, end, this.start, this.end), shareStart = _ref3[0], shareEnd = _ref3[1];
      toRemove = [];
      _ref4 = this.bufferList;
      for (index = _k = 0, _len1 = _ref4.length; _k < _len1; index = ++_k) {
        item = _ref4[index];
        if (!between(shareStart, shareEnd, item.pack.index)) {
          toRemove.push(item);
        }
      }
      for (_l = 0, _len2 = toRemove.length; _l < _len2; _l++) {
        item = toRemove[_l];
        this.bufferList.removeItem(item);
      }
      befores = [];
      afters = [];
      for (index = _m = start; start <= end ? _m <= end : _m >= end; index = start <= end ? ++_m : --_m) {
        if (index < 0) {
          break;
        }
        pack = this.packs[index];
        if (index < shareStart) {
          befores.push(pack.widget);
        } else if (index > shareEnd) {
          afters.push(pack.widget);
        }
      }
      if (befores.length > 0) {
        (_ref5 = this.bufferList).splice.apply(_ref5, [0, 0].concat(__slice.call(befores)));
      }
      if (afters.length > 0) {
        (_ref6 = this.bufferList).splice.apply(_ref6, [this.bufferList.length, 0].concat(__slice.call(afters)));
      }
      if (this.bufferList.length !== 0 && this.bufferList.length !== end - start + 1) {
        console.debug(this.bufferList.length, start, end);
        throw new Error("invalid splice action");
      }
      this.start = start;
      this.end = end;
      if (this.bufferList.length > 0) {
        this.top = this.bufferList[0].pack.top;
        this.buffer$.css({
          top: this.top
        });
      }
      bufferViewPort = this.getBufferViewPort();
      if (bufferViewPort.bottom < viewPort.bottom) {
        toAddStart = null;
        toAddEnd = this.end;
        for (index = _n = _ref7 = this.end + 1, _ref8 = this.packs.length; _ref7 <= _ref8 ? _n < _ref8 : _n > _ref8; index = _ref7 <= _ref8 ? ++_n : --_n) {
          pack = this.packs[index];
          if (!pack) {
            break;
          }
          pack.realize();
          this.bufferList.push(pack.widget);
          pack.calculateSize();
          pack.top = bufferViewPort.bottom;
          pack.bottom = pack.top + pack.size.height;
          bufferViewPort.bottom = pack.bottom;
          if (toAddStart === null) {
            toAddStart = index;
          }
          toAddEnd = index;
          if (viewPort.bottom < bufferViewPort.bottom) {
            break;
          }
        }
        if (this.start === -1 && toAddStart) {
          this.start = toAddStart;
        }
        this.end = toAddEnd;
      }
      this.wrapper.style.minHeight = "" + (bufferViewPort.bottom + this.bottomPadding) + "px";
      if (this._hint) {
        this.buffer.appendChild(this._hint);
      }
      if (bufferViewPort.bottom < viewPort.bottom) {
        this.emit("requireMore");
      }
      return this.emit("reflow");
    };

    EndlessListRenderer.prototype.setHint = function(node) {
      if (this._hint && this.buffer.contains(this._hint) && this._hint !== node) {
        this.buffer.removeChild(this._hint);
      }
      if (node === this._hint) {
        return;
      }
      this._hint = node;
      return this.buffer.appendChild(node);
    };

    EndlessListRenderer.prototype.reflowAfter = function(after) {
      var index, item, next, _i, _ref;
      if (after < 0) {
        return;
      }
      next = null;
      for (index = _i = after, _ref = this.packs.length; after <= _ref ? _i < _ref : _i > _ref; index = after <= _ref ? ++_i : --_i) {
        item = this.packs[index];
        if (!item.size) {
          return;
        }
        if (next !== null) {
          item.top = next;
        } else {
          next = item.top || 0;
        }
        next += item.size.height;
        item.bottom = next;
      }
    };

    EndlessListRenderer.prototype.getBufferViewPort = function() {
      var bottom, height, top;
      height = this.buffer$.height();
      top = this.top;
      bottom = this.top + height;
      return {
        top: top,
        bottom: bottom,
        height: height
      };
    };

    EndlessListRenderer.prototype.getViewPort = function(fix) {
      var bottom, height, top;
      if (fix == null) {
        fix = 0;
      }
      top = this.scrollable.scrollTop;
      height = $(this.scrollable).height();
      bottom = top + height;
      top -= fix;
      bottom += fix;
      if (top < 0) {
        top = 0;
      }
      height = bottom - top;
      return {
        top: top,
        height: height,
        bottom: bottom
      };
    };

    return EndlessListRenderer;

  })(Leaf.EventEmitter);

  Pack = (function(_super) {
    __extends(Pack, _super);

    function Pack(data, createMethod) {
      this.data = data;
      this.createMethod = createMethod;
    }

    Pack.prototype.realize = function() {
      this.widget = this.createMethod(this.data);
      this.widget.pack = this;
      return this.widget;
    };

    Pack.prototype.destroy = function() {
      return this.widget = null;
    };

    Pack.prototype.calculateSize = function() {
      var _ref, _ref1;
      if (!((_ref = this.widget) != null ? (_ref1 = _ref.node) != null ? _ref1.parentElement : void 0 : void 0)) {
        return;
      }
      return this.size = this.widget.node.getBoundingClientRect();
    };

    return Pack;

  })(Leaf.EventEmitter);

  module.exports = EndlessListRenderer;

}).call(this);
